from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
from webdriver_manager.chrome import ChromeDriverManager
import re

from bs4 import BeautifulSoup

def init_driver() -> webdriver.Chrome:
    """
    Chrome 드라이버를 초기화하고 반환한다.
    - headless=False (브라우저 표시)
    - detach 옵션으로 스크립트 종료 후에도 브라우저 유지
    """
    options = Options()
    options.headless = False
    options.add_experimental_option("detach", True)
    options.add_argument("--start-maximized")
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service, options=options)
    driver.implicitly_wait(2)
    return driver


def Maps_to(driver: webdriver.Chrome, url: str, timeout: int = 15) -> bool:
    """
    주어진 URL로 이동한 뒤 DOM 로딩을 대기한다.
    오류 시 False 반환.
    """
    try:
        driver.get(url)
        WebDriverWait(driver, timeout).until(
            lambda d: d.execute_script("return document.readyState") == "complete"
        )
        return True
    except TimeoutException:
        print(f"[Maps_to] 로딩 시간 초과: {url}")
    except Exception as exc:  # pylint: disable=broad-except
        print(f"[Maps_to] 이동 중 오류 발생: {exc}")
    return False
    
def get_OP(driver: webdriver.Chrome, after_login_url: str):
     # 로그인 하고 고전독서센터 페이지로 이동
    if Maps_to(driver, after_login_url):
        WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.TAG_NAME, "body")))
        print("목표 페이지로 이동 완료")
        # 이동해서 onclick 속성에서 값 추출, 근데 만약 없으면 에러 처리
        if driver.find_elements(By.CSS_SELECTOR, "button.btn.btn-warning"):
            print("예약된 항목이 있습니다.")
        else:
            print("예약된 항목이 없습니다.")
            return -1
        for btn in driver.find_elements(By.CSS_SELECTOR, "button.btn.btn-warning"):
            print("버튼 텍스트:", btn.text)
        # btn = driver.find_element(By.CSS_SELECTOR, "button.btn.btn-warning[onclick^=\"cancelApp\"]")
        if btn is None:
            raise Exception(" 예약 후 시도하세요")
        onclick = btn.get_attribute("onclick")
        print("onclick 속성:", onclick)
        value = onclick.split("'")[1]
        print("추출한 값:", value)
        # m = re.search(r"cancelApp\\('([^']+)'\\)", onclick)
        # value = m.group(1) if m else None
    else :
        return -1
    
    return value

def get_test(driver: webdriver.Chrome, test_url: str, OP_value: str):
    if Maps_to(driver, test_url + OP_value):
        try:
            WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.TAG_NAME, "body")))
            print("시험 페이지로 이동 완료")
            html = driver.page_source
            soup = BeautifulSoup(html, 'html.parser')
            question_items = soup.select("ol.listBox > li")
            results = []
            print(f"총 {len(question_items)}개의 문제를 찾았습니다.\n")
            for item in question_items:
                # --- [1] 질문 제목 추출 ---
                title_div = item.select_one(".question-title")
                
                # 번호 추출 (span 태그)
                q_num = title_div.select_one("span").get_text(strip=True)
                
                # 질문 내용 추출 
                # (번호인 '1', '2' 등을 제외한 나머지 텍스트만 가져오기 위해 처리)
                full_text = title_div.get_text(separator=" ", strip=True)
                q_text = full_text.replace(q_num, "", 1).strip() # 맨 앞 번호 제거
                
                # --- [2] 보기(선택지) 추출 ---
                options = []
                option_items = item.select(".question-list li label") # 보기의 텍스트는 label 태그 안에 있음
                
                for opt in option_items:
                    options.append(opt.get_text(strip=True))
                
                # --- [3] 데이터 저장 ---
                question_data = {
                    "no": q_num,
                    "question": q_text,
                    "options": options
                }
                results.append(question_data)
                
                # --- [4] 출력 확인 ---
                print(f"Q{q_num}. {q_text}")
                for idx, opt in enumerate(options, 1):
                    print(f"  {idx}) {opt}")
                print("-" * 50)
            return results
        except TimeoutException:
            print("목표 페이지 로딩 대기 중 시간 초과")

def cancel_reservation(driver: webdriver.Chrome, after_login_url: str):
    # 로그인 하고 고전독서센터 페이지로 이동
    if Maps_to(driver, after_login_url):
        WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.TAG_NAME, "body")))
        print("목표 페이지로 이동 완료")
        # 이동해서 onclick 속성에서 값 추출, 근데 만약 없으면 에러 처리
        if driver.find_elements(By.CSS_SELECTOR, "button.btn.btn-warning"):
            print("예약된 항목이 있습니다.")
        else:
            print("예약된 항목이 없습니다.")
            return -1
        for btn in driver.find_elements(By.CSS_SELECTOR, "button.btn.btn-warning"):
            print("버튼 텍스트:", btn.text)
        # btn = driver.find_element(By.CSS_SELECTOR, "button.btn.btn-warning[onclick^=\"cancelApp\"]")
        if btn is None:
            raise Exception(" 예약 후 시도하세요")
        onclick = btn.get_attribute("onclick")
        print("onclick 속성:", onclick)
        value = onclick.split("'")[1]
        print("추출한 값:", value)
        # m = re.search(r"cancelApp\\('([^']+)'\\)", onclick)
        # value = m.group(1) if m else None
    else :
        return -1
    
    return value


if __name__ == "__main__":
    main_url = "https://classic.sejong.ac.kr/classic/index.do"
    after_login_url = "https://classicad.sejong.ac.kr/sso_login.jsp"
    test_url = "https://classicad.sejong.ac.kr/viewQuestion.do?opAppInfoId="

    driver = init_driver()

    if not Maps_to(driver, main_url):
        raise SystemExit("초기 페이지 로딩 실패")
    print("초기 페이지 로딩 완료")
    
    # 로그인될 때까지 대기
    for a in driver.find_elements(By.TAG_NAME, "a"):
        if "로그인" in a.text:
            input("로그인/인증을 완료한 뒤 Enter 키를 누르세요... ")
            break
        
    method = int(input("원하는 방법을 선택해주세요(0:당장 예약한 시험 뽑기, 1: 모든 시험 뽑기) :"))
    
    if method == 0:
        # 예약이 될 때까지 확인
        while True:
            OP_value = get_OP(driver, after_login_url)
            if OP_value == -1:
                input("예약 정보 없음, 예약 후 Enter 키를 누르세요... ")
            else:
                print("예약 정보 로딩 완료, OP_value:", OP_value)
                break
        # 시험 문제 가져오기
        test_info = get_test(driver, test_url, OP_value)
        
        # text 파일로 저장
        with open("sejong_test.txt", "w", encoding="utf-8") as f:
            for item in test_info:
                f.write(f"Q{item['no']}. {item['question']}\n")
                for idx, opt in enumerate(item['options'], 1):
                    f.write(f"  {idx}) {opt}\n")
                f.write("-" * 50 + "\n")
        print("시험 정보가 sejong_test.txt 파일로 저장되었습니다.")
        
    elif method == 1:
        print("모든 시험 뽑기 기능은 아직 구현되지 않았습니다.")
        
        
    driver.quit()
        
        